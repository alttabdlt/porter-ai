<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Porter.AI - Monitoring Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ff88;
            margin-bottom: 30px;
            font-size: 24px;
            font-weight: normal;
            letter-spacing: 2px;
        }
        
        /* Section 1: Screen Activity */
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .section-title {
            color: #00ff88;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .screen-grid {
            display: grid;
            grid-template-columns: 200px 1fr 1fr;
            gap: 20px;
            align-items: start;
        }
        
        .screen-grid-header {
            display: contents;
            font-weight: bold;
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
        }
        
        .screen-grid-header > div {
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
        }
        
        .screen-event {
            display: contents;
        }
        
        .screenshot-col {
            position: relative;
        }
        
        .screenshot {
            width: 100%;
            height: 120px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            object-fit: cover;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 12px;
        }
        
        .screenshot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 4px;
        }
        
        .timestamp {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            color: #888;
        }
        
        .vlm-description {
            padding: 10px;
            background: #222;
            border-left: 3px solid #00ff88;
            border-radius: 4px;
            font-size: 14px;
            min-height: 120px;
        }
        
        .tts-decision {
            padding: 10px;
            background: #222;
            border-radius: 4px;
            font-size: 14px;
            min-height: 120px;
        }
        
        .tts-decision.speaking {
            border-left: 3px solid #00ff88;
            background: #1a2a1a;
        }
        
        .tts-decision.silent {
            border-left: 3px solid #666;
            color: #888;
        }
        
        .importance-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .importance-fill {
            height: 100%;
            background: linear-gradient(90deg, #666, #00ff88);
            transition: width 0.3s ease;
        }
        
        .spoken-text {
            margin-top: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            font-style: italic;
            color: #00ff88;
        }
        
        /* Section 2: Voice Interaction */
        .voice-log {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: #0a0a0a;
            border-radius: 4px;
        }
        
        .voice-entry {
            margin-bottom: 15px;
            padding: 12px;
            background: #1a1a1a;
            border-radius: 4px;
            border-left: 3px solid #333;
        }
        
        .voice-entry.user {
            border-left-color: #4a9eff;
        }
        
        .voice-entry.ai {
            border-left-color: #00ff88;
        }
        
        .voice-label {
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 5px;
        }
        
        .voice-text {
            font-size: 14px;
            line-height: 1.4;
        }
        
        .voice-entry.user .voice-label {
            color: #4a9eff;
        }
        
        .voice-entry.ai .voice-label {
            color: #00ff88;
        }
        
        /* Status indicators */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: #1a1a1a;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 12px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-dot.active {
            background: #00ff88;
            animation: pulse 2s infinite;
        }
        
        .status-dot.listening {
            background: #4a9eff;
            animation: pulse 1s infinite;
        }
        
        .status-dot.speaking {
            background: #ffa500;
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }
        
        /* Tier badges */
        .tier-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 8px;
        }
        
        .tier-badge.critical {
            background: #ff3838;
            color: white;
        }
        
        .tier-badge.important {
            background: #ffa500;
            color: white;
        }
        
        .tier-badge.routine {
            background: #666;
            color: #ccc;
        }
        
        /* Fade animations */
        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(0.98);
            }
            100% {
                opacity: 0;
                transform: scale(0.95);
                height: 0;
                padding: 0;
                margin: 0;
            }
        }
        
        .screen-event.fading {
            animation: fadeOut 0.5s ease-out forwards;
        }
        
        @keyframes slideIn {
            0% {
                opacity: 0;
                transform: translateY(-20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .screen-event.new {
            animation: slideIn 0.3s ease-out;
        }
        
        /* TTL timer */
        .ttl-timer {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            color: #ffa500;
        }
        
        /* Memory indicator */
        .memory-indicator {
            display: inline-block;
            margin-left: 10px;
            font-size: 11px;
            color: #888;
        }
        
        .memory-bar {
            display: inline-block;
            width: 100px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            vertical-align: middle;
            margin-left: 5px;
            overflow: hidden;
        }
        
        .memory-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffa500, #ff3838);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PORTER.AI - MONITORING DASHBOARD</h1>
        
        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-indicator">
                <span class="status-dot active" id="system-status"></span>
                <span>System Active</span>
            </div>
            <div class="status-indicator">
                <span class="status-dot" id="listening-status"></span>
                <span>Listening</span>
            </div>
            <div class="status-indicator">
                <span class="status-dot" id="speaking-status"></span>
                <span>Speaking</span>
            </div>
            <div class="status-indicator">
                <span id="event-count">0</span> events | 
                <span id="interaction-count">0</span> interactions
                <span class="memory-indicator">
                    Memory: <span id="memory-percent">0</span>%
                    <span class="memory-bar">
                        <div class="memory-fill" id="memory-fill" style="width: 0%"></div>
                    </span>
                </span>
            </div>
        </div>
        
        <!-- Section 1: Screen Activity -->
        <div class="section">
            <div class="section-title">Section 1: Screen Activity Monitor</div>
            <div class="screen-grid">
                <div class="screen-grid-header">
                    <div>Screenshot</div>
                    <div>VLM Description</div>
                    <div>TTS Decision</div>
                </div>
                <div id="screen-events">
                    <!-- Events will be inserted here -->
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        Waiting for screen activity...
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Section 2: Voice Interaction Log -->
        <div class="section">
            <div class="section-title">Section 2: Voice Interaction Log</div>
            <div class="voice-log" id="voice-log">
                <div class="empty-state">
                    No voice interactions yet...
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Screenshot management system
        class ScreenshotManager {
            constructor(maxMemoryMB = 50) {
                this.screenshots = new Map(); // id -> {data, tier, ttl, timestamp}
                this.maxMemoryBytes = maxMemoryMB * 1024 * 1024;
                this.currentMemoryBytes = 0;
                this.ttlTimers = new Map();
                this.startCleanupInterval();
            }
            
            add(eventId, screenshot, tier, ttl) {
                if (!screenshot) return;
                
                // Calculate approximate size (base64 is ~1.33x original)
                const sizeBytes = Math.floor(screenshot.length * 0.75);
                
                // Check if we need to make room
                if (this.currentMemoryBytes + sizeBytes > this.maxMemoryBytes) {
                    this.evictLowestPriority(sizeBytes);
                }
                
                // Store screenshot
                this.screenshots.set(eventId, {
                    data: screenshot,
                    tier: tier,
                    ttl: ttl,
                    timestamp: Date.now(),
                    size: sizeBytes
                });
                
                this.currentMemoryBytes += sizeBytes;
                
                // Set TTL timer if needed
                if (ttl) {
                    this.setTTLTimer(eventId, ttl);
                }
                
                this.updateMemoryIndicator();
            }
            
            setTTLTimer(eventId, ttlSeconds) {
                // Clear existing timer if any
                if (this.ttlTimers.has(eventId)) {
                    clearTimeout(this.ttlTimers.get(eventId));
                }
                
                // Set new timer
                const timer = setTimeout(() => {
                    this.remove(eventId, true);
                }, ttlSeconds * 1000);
                
                this.ttlTimers.set(eventId, timer);
            }
            
            remove(eventId, animate = false) {
                const screenshot = this.screenshots.get(eventId);
                if (!screenshot) return;
                
                // Clear TTL timer
                if (this.ttlTimers.has(eventId)) {
                    clearTimeout(this.ttlTimers.get(eventId));
                    this.ttlTimers.delete(eventId);
                }
                
                // Remove from memory
                this.currentMemoryBytes -= screenshot.size;
                this.screenshots.delete(eventId);
                
                // Animate removal in UI
                if (animate) {
                    const element = document.querySelector(`[data-event-id="${eventId}"]`);
                    if (element) {
                        element.classList.add('fading');
                        setTimeout(() => element.remove(), 500);
                    }
                }
                
                this.updateMemoryIndicator();
            }
            
            evictLowestPriority(bytesNeeded) {
                // Sort by priority: routine < important < critical, then by age
                const sorted = Array.from(this.screenshots.entries())
                    .sort((a, b) => {
                        const tierOrder = {routine: 0, important: 1, critical: 2};
                        const tierDiff = tierOrder[a[1].tier] - tierOrder[b[1].tier];
                        if (tierDiff !== 0) return tierDiff;
                        return a[1].timestamp - b[1].timestamp; // Older first
                    });
                
                let freedBytes = 0;
                for (const [eventId, screenshot] of sorted) {
                    if (screenshot.tier === 'critical') break; // Never evict critical
                    
                    this.remove(eventId, true);
                    freedBytes += screenshot.size;
                    
                    if (freedBytes >= bytesNeeded) break;
                }
            }
            
            startCleanupInterval() {
                // Check for expired screenshots every 10 seconds
                setInterval(() => {
                    const now = Date.now();
                    for (const [eventId, screenshot] of this.screenshots.entries()) {
                        if (screenshot.ttl) {
                            const elapsed = (now - screenshot.timestamp) / 1000;
                            if (elapsed >= screenshot.ttl) {
                                this.remove(eventId, true);
                            }
                        }
                    }
                }, 10000);
            }
            
            updateMemoryIndicator() {
                const percent = Math.round((this.currentMemoryBytes / this.maxMemoryBytes) * 100);
                document.getElementById('memory-percent').textContent = percent;
                document.getElementById('memory-fill').style.width = `${percent}%`;
                
                // Show count by tier
                let critical = 0, important = 0, routine = 0;
                for (const screenshot of this.screenshots.values()) {
                    if (screenshot.tier === 'critical') critical++;
                    else if (screenshot.tier === 'important') important++;
                    else routine++;
                }
                
                console.log(`Screenshots: ${critical} critical, ${important} important, ${routine} routine (${(this.currentMemoryBytes / 1024 / 1024).toFixed(1)}MB)`);
            }
            
            getMemoryUsageMB() {
                return this.currentMemoryBytes / 1024 / 1024;
            }
        }
        
        // WebSocket connection for real-time updates
        let ws = null;
        let eventCount = 0;
        let interactionCount = 0;
        let screenshotManager = new ScreenshotManager(50); // 50MB max
        let eventIdCounter = 0;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8001/ws');
            
            ws.onopen = () => {
                console.log('Connected to Porter.AI');
                document.getElementById('system-status').classList.add('active');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('Disconnected from Porter.AI');
                document.getElementById('system-status').classList.remove('active');
                // Reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };
        }
        
        function handleMessage(message) {
            if (message.type === 'screen_event') {
                addScreenEvent(message.data);
            } else if (message.type === 'voice_interaction') {
                addVoiceInteraction(message.data);
            } else if (message.type === 'status') {
                updateStatus(message.data);
            } else if (message.type === 'memory_stats') {
                updateMemoryStats(message.data);
            }
        }
        
        function updateMemoryStats(stats) {
            // Update memory display with backend stats
            const memoryInfo = document.createElement('div');
            memoryInfo.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #00ff88; padding: 10px; border-radius: 5px; font-size: 12px; z-index: 1000;';
            memoryInfo.innerHTML = `
                <div style="margin-bottom: 5px;">ðŸ“Š SYSTEM MEMORY</div>
                <div>Backend: ${stats.current_mb.toFixed(1)}MB (peak: ${stats.peak_mb.toFixed(1)}MB)</div>
                <div>Growth: ${stats.growth_mb.toFixed(1)}MB</div>
                <div>Events: ${stats.event_count} | Screenshots: ${stats.screenshot_count}</div>
                <div>CPU: ${stats.cpu_percent.toFixed(1)}%</div>
                <div>Frontend: ${screenshotManager.getMemoryUsageMB().toFixed(1)}MB / 50MB</div>
            `;
            
            // Remove old stats if exists
            const oldStats = document.getElementById('backend-memory-stats');
            if (oldStats) oldStats.remove();
            
            memoryInfo.id = 'backend-memory-stats';
            document.body.appendChild(memoryInfo);
            
            // Auto-remove after 5 seconds to avoid clutter
            setTimeout(() => memoryInfo.style.opacity = '0.5', 4000);
            
            // Log to console for debugging
            console.log('Memory Stats:', stats);
        }
        
        function addScreenEvent(event) {
            eventCount++;
            document.getElementById('event-count').textContent = eventCount;
            
            const container = document.getElementById('screen-events');
            
            // Remove empty state if exists
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Generate unique event ID
            const eventId = `event-${++eventIdCounter}`;
            
            // Add screenshot to manager if present
            if (event.screenshot) {
                screenshotManager.add(eventId, event.screenshot, event.tier || 'routine', event.ttl);
            }
            
            // Create event elements
            const eventDiv = document.createElement('div');
            eventDiv.className = 'screen-event new';
            eventDiv.setAttribute('data-event-id', eventId);
            
            // Calculate TTL display
            let ttlDisplay = '';
            if (event.ttl) {
                ttlDisplay = `<span class="ttl-timer" data-ttl="${event.ttl}">TTL: ${event.ttl}s</span>`;
            }
            
            eventDiv.innerHTML = `
                <div class="screenshot-col">
                    <div class="screenshot">
                        ${event.screenshot ? `<img src="${event.screenshot}" alt="Screen capture">` : 
                          (event.has_screenshot ? '<div style="color: #444;">Screenshot skipped</div>' : 'No image')}
                        <span class="timestamp">${formatTime(event.timestamp)}</span>
                        ${ttlDisplay}
                    </div>
                </div>
                <div class="vlm-description">
                    ${event.description}
                    <span class="tier-badge ${event.tier || 'routine'}">${event.tier || 'routine'}</span>
                </div>
                <div class="tts-decision ${event.spoken ? 'speaking' : 'silent'}">
                    <div>Importance: ${(event.importance * 100).toFixed(0)}%</div>
                    <div class="importance-bar">
                        <div class="importance-fill" style="width: ${event.importance * 100}%"></div>
                    </div>
                    ${event.spoken ? 
                        '<div class="spoken-text">âœ“ Speaking: "' + event.spoken + '"</div>' : 
                        '<div style="color: #666; margin-top: 8px;">âœ— Silent</div>'
                    }
                </div>
            `;
            
            // Insert at the beginning (newest first)
            container.insertBefore(eventDiv, container.firstChild);
            
            // Remove 'new' class after animation
            setTimeout(() => eventDiv.classList.remove('new'), 300);
            
            // Update TTL timers
            if (event.ttl) {
                startTTLCountdown(eventDiv.querySelector('.ttl-timer'), event.ttl);
            }
            
            // Keep max 20 events in UI (but screenshots managed separately)
            while (container.children.length > 60) { // 3 elements per event * 20 events
                const lastEvent = container.lastChild;
                const lastEventId = lastEvent.getAttribute('data-event-id');
                if (lastEventId) {
                    screenshotManager.remove(lastEventId, false);
                }
                container.removeChild(lastEvent);
            }
        }
        
        function startTTLCountdown(element, ttlSeconds) {
            if (!element) return;
            
            let remaining = ttlSeconds;
            const interval = setInterval(() => {
                remaining--;
                if (remaining <= 0) {
                    clearInterval(interval);
                    element.textContent = 'Expiring...';
                    element.style.color = '#ff3838';
                } else if (remaining <= 10) {
                    element.textContent = `TTL: ${remaining}s`;
                    element.style.color = '#ffa500';
                } else {
                    element.textContent = `TTL: ${remaining}s`;
                }
            }, 1000);
        }
        
        function addVoiceInteraction(interaction) {
            interactionCount++;
            document.getElementById('interaction-count').textContent = interactionCount;
            
            const voiceLog = document.getElementById('voice-log');
            
            // Remove empty state if exists
            const emptyState = voiceLog.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Add user message
            if (interaction.user_said) {
                const userEntry = document.createElement('div');
                userEntry.className = 'voice-entry user';
                userEntry.innerHTML = `
                    <div class="voice-label">USER (${formatTime(interaction.timestamp)})</div>
                    <div class="voice-text">${interaction.user_said}</div>
                `;
                voiceLog.appendChild(userEntry);
            }
            
            // Add AI response
            if (interaction.ai_response) {
                const aiEntry = document.createElement('div');
                aiEntry.className = 'voice-entry ai';
                aiEntry.innerHTML = `
                    <div class="voice-label">AI (${formatTime(interaction.timestamp)})</div>
                    <div class="voice-text">${interaction.ai_response}</div>
                `;
                voiceLog.appendChild(aiEntry);
            }
            
            // Auto-scroll to bottom
            voiceLog.scrollTop = voiceLog.scrollHeight;
            
            // Keep only last 20 entries
            while (voiceLog.children.length > 20) {
                voiceLog.removeChild(voiceLog.firstChild);
            }
        }
        
        function updateStatus(status) {
            if (status.listening) {
                document.getElementById('listening-status').classList.add('listening');
            } else {
                document.getElementById('listening-status').classList.remove('listening');
            }
            
            if (status.speaking) {
                document.getElementById('speaking-status').classList.add('speaking');
            } else {
                document.getElementById('speaking-status').classList.remove('speaking');
            }
        }
        
        function formatTime(timestamp) {
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        // Connect on load
        connectWebSocket();
        
        // Simulate some test data for development
        if (window.location.search.includes('test')) {
            setTimeout(() => {
                addScreenEvent({
                    timestamp: Date.now() / 1000,
                    description: "User opened terminal in VS Code",
                    importance: 0.7,
                    spoken: "I see you've opened the terminal"
                });
            }, 1000);
            
            setTimeout(() => {
                addVoiceInteraction({
                    timestamp: Date.now() / 1000,
                    user_said: "Yes, I need to run some tests",
                    ai_response: "Would you like help with pytest commands?"
                });
            }, 2000);
            
            setTimeout(() => {
                addScreenEvent({
                    timestamp: Date.now() / 1000,
                    description: "Browser displaying Python documentation",
                    importance: 0.3,
                    spoken: null
                });
            }, 3000);
        }
    </script>
</body>
</html>